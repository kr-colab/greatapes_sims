initialize() {
    if(exists("rescf")) {
        defineConstant("Q", asInteger(rescf));
    } else {
        defineConstant("Q", 1);
    }
    if (exists("seed")) {
        setSeed(asInteger(seed));
    }
    if (exists("poscoefdecayeps")) {
        defineConstant("eps", asFloat(poscoefdecayeps));
    }
    // this should be used for sims with large populations being run for a long period of time. the number of nodes in the treeseq explodes.
    if (exists("siminterval")) {
        if (siminterval =="") {
            initializeTreeSeq();
        } else {
            catn("Setting simplification interval");
            initializeTreeSeq(simplificationInterval=asInteger(siminterval));       
        }
    } else {
        initializeTreeSeq();
    }
    initializeMutationRate(asFloat(mu)*Q);
    //del mutations
    initializeMutationType("m1", 0.5, "g", asFloat(delcoef)*Q, 0.16); //shape per Castellano et al 2019 Genetics
    initializeMutationType("m2", 0.5, "e", asFloat(poscoef)*Q);
    initializeGenomicElementType("g1", c(m1,m2), c(asFloat(delprop),asFloat(posprop)));	
    f = readFile(exonfile);
    i = 0;
    start_coords = c();
    end_coords = c();
    for (line in f) {
        coord = asInteger(strsplit(line[0], "\t")[1:2]);
        // just in case my file goes for longer than the stretch I want to simulate
        if (coord[0] > asInteger(L)-1) {
            catn("Elements in exonfile span a region larger than the implied by L.");
            break;
        }
        if(coord[1] > asInteger(L)-1) {
            catn("Trimming exon element. Elements in exonfile span a region larger than the implied by L.");
            coord[1] = asInteger(L)-1;
        }
        start_coords = c(start_coords, coord[0]);
        // the -1 in the end coordinate is bc bed are not inclusive, but slim is
        end_coords = c(end_coords, coord[1]-1);
        i=i+1;
    }
    if(i==0) {
        catn("No elements in exonfile. Starting a chromosome with one element of length L instead.");
        initializeGenomicElement(g1, 0, asInteger(L)-1);
    } else {
        initializeGenomicElement(g1, start_coords, end_coords);
    }
    //reading rec map
    lines = readFile(recfile);
    rates=NULL;
    ends=NULL;
    for (line in lines) {
            cols = strsplit(line,"\t");
            ends = c(ends, asInteger(cols[2])-1);
            rates = c(rates, asFloat(cols[3]));
    }
    // IMPLEMENT CASE WHERE L IS SMALLER THAN REC MAP
    if (ends[length(ends)-1] > asInteger(L)-1) {
        catn("Rec map spans a larger region than the length of chromsome L. Trimming the map.");
        // adding a conditional to make sure rec is at least the first rate
        if(ends[0] > asInteger(L)-1) {
            ends[0]=asInteger(L)-1;
        }
        rates=rates[ends<asInteger(L)];
        ends=ends[ends<asInteger(L)];
        ends[length(ends)-1] = asInteger(L)-1;
    }
    // CASE WHERE LAST END IS SMALLER THAN REC MAP
    if (ends[length(ends)-1]< asInteger(L)-1) {
        catn("Rec map spans a smaller region than the length of the chromosome. Adding 0 rec from there on.");
        ends = c(ends,asInteger(L)-1);
        rates=c(rates,0.0);
    }
    // rescaling rates
    rates = rates * 1e-8;
    rates=(1-(1-2*rates)^Q)/2;
    initializeRecombinationRate(rates,ends);
}

1 early() {
    // registering late events that decay pos coef every generation by eps
    if(exists("eps")) {
        if (eps > 0 + 1e-12) {
            sim.registerLateEvent(3, "{m2muts = sim.mutationsOfType(m2); for (mut in m2muts) { mut.setSelectionCoeff(mut.selectionCoeff * (1-eps));};}");
        }
    }
}

1 late() {
    // rescaling pop size and generations
    pop_size = integerDiv(asInteger(N),Q);
    n_gens = integerDiv(asInteger(gens),Q);
    at_gen = 0;
    // making sure the path constant exists
    if (!exists("path_population_tree"))
        defineConstant("path_population_tree", "");
    // setting path to infile -- restarting from there
    infile = path_population_tree;
    // checking if any intermediate file has been saved
    // so that we can restart from there
    if (n_gens > 5000) {
        outs = system("python /home/murillor/projects/greatapes_sims/scripts/py/find_temp_trees.py "+outfile);
        if (length(outs) == 2)
        {
            infile = outs[0];
            at_gen = asInteger(outs[1]);
            catn("Found intermediate TreeSequence to start from: "+infile+" - generation "+asString(at_gen));
        }
    }
    if (infile == "") {
        sim.addSubpop("p1", pop_size);
    } else {
        catn("Reading previous sim from file "+infile);
        sim.readFromPopulationFile(infile);
        p1.setSubpopulationSize(pop_size);
    }
    // defining start gen
    defineConstant("branch_start_gen", sim.generation-at_gen);
    defineConstant("sim_start_gen", sim.generation);
    catn("Starting sim from generation: "+asString(sim_start_gen)+", Branch started at: "+asString(branch_start_gen));
    // rescheduling the time to end simulation
    sim.rescheduleScriptBlock(s0, generations=branch_start_gen+n_gens);
    //schedule sampling in equaly spaced intervals
    intervals = 1:3/4;
    remember_times = branch_start_gen+asInteger(ceil(intervals*n_gens));
    remember_times = remember_times[remember_times > sim_start_gen];
    if (length(remember_times[remember_times == sim_start_gen]) > 0)
    {
        catn("Remembering at generation "+sim.generation);
        sim.treeSeqRememberIndividuals(sim.subpopulations.individuals);
    }
    if (length(remember_times) > 0)
        sim.rescheduleScriptBlock(s1, generations=remember_times);
    // scheduling saving output + progress messages
    if (n_gens > 5000) {
        saving_times = branch_start_gen+seq(5000, n_gens, 5000);
        saving_times = saving_times[saving_times > sim_start_gen];
        if (length(saving_times) > 0)
            sim.rescheduleScriptBlock(s2, generations=saving_times);
    }
}

late() {

}

// final event: save tree seq
s0 5 late() {
	sim.treeSeqRememberIndividuals(sim.subpopulations.individuals);
    sim.treeSeqOutput(outfile);
	catn("Saving output tree in generation "+sim.generation);
    catn("To file: "+outfile);
    system("python /home/murillor/projects/greatapes_sims/scripts/py/clear_temp_trees.py "+outfile);
    catn("Clearing intermediate tree files");
}

// remembering individuals
s1 5 late() {
    catn("Remembering at generation "+sim.generation);
    sim.treeSeqRememberIndividuals(sim.subpopulations.individuals);
}

// progress + saving trees
s2 5 late() {
    gen = (sim.generation-branch_start_gen);
    if (gen % 5000 == 0) {
        catn("You got to generation "+sim.generation);
    }
    if (gen % 10000 == 0) {
        catn("Saving tree generation "+ sim.generation);
        sim.treeSeqOutput(outfile+asString(gen));
    }
}

